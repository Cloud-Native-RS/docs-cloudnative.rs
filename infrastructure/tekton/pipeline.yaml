apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: cn-docs-pipeline
  namespace: cn-docs
  labels:
    app: cn-docs
    pipeline: ci-cd
spec:
  description: "CI/CD Pipeline for Cloud Native Documentation"
  
  params:
    - name: git-url
      description: "Git repository URL (HTTPS with token or SSH)"
      default: "https://github.com/Cloud-Native-RS/docs-cloudnative.rs.git"
    - name: git-revision
      description: "Git revision to build"
      default: "main"
    - name: image-repository
      description: "Container image repository"
      default: "image-registry.openshift-image-registry.svc:5000/cn-docs/cn-docs"
    - name: image-tag
      description: "Container image tag"
      default: "latest"
    - name: project-name
      description: "OpenShift project name"
      default: "cn-docs"

  workspaces:
    - name: shared-workspace
      description: "Shared workspace for pipeline tasks"

  tasks:
    # Task 1: Clone Git repository with authentication
    - name: git-clone
      taskSpec:
        description: "Clone git repository with authentication support"
        params:
          - name: url
            description: "git url to clone"
            type: string
          - name: revision
            description: "git revision to checkout"
            type: string
            default: "main"
        workspaces:
          - name: output
            description: "The git repo will be cloned onto this workspace"
        steps:
          - name: clone
            image: alpine/git:latest
            workingDir: $(workspaces.output.path)
            env:
              - name: HOME
                value: /tekton/home
            script: |
              #!/bin/sh
              set -xe
              
              # Clean workspace
              rm -rf ./* .git || true
              
              # Configure git
              export GIT_CONFIG_GLOBAL=/tmp/gitconfig
              git config --global safe.directory '*'
              git config --global http.sslVerify false
              
              # Setup authentication using mounted secrets
              if [ -f /etc/git-secret/username ] && [ -f /etc/git-secret/password ]; then
                echo "Using GitHub token authentication"
                USERNAME=$(cat /etc/git-secret/username)
                PASSWORD=$(cat /etc/git-secret/password)
                # Create authenticated URL
                AUTH_URL=$(echo "$(params.url)" | sed "s|https://github.com|https://$USERNAME:$PASSWORD@github.com|")
                echo "Cloning with authentication..."
                git clone "$AUTH_URL" .
              else
                echo "No authentication found, trying public clone"
                git clone $(params.url) .
              fi
              
              # Checkout specific revision
              git checkout $(params.revision)
              
              echo "Repository cloned successfully"
              echo "Current branch: $(git branch --show-current)"
              ls -la
            volumeMounts:
              - name: git-secret
                mountPath: /etc/git-secret
                readOnly: true
        volumes:
          - name: git-secret
            secret:
              secretName: github-auth-secret
              optional: true
      params:
        - name: url
          value: $(params.git-url)
        - name: revision
          value: $(params.git-revision)
      workspaces:
        - name: output
          workspace: shared-workspace

    # Task 2: Build application using NodeJS
    - name: build-app
      runAfter: ["git-clone"]
      taskSpec:
        description: "Build NodeJS application"
        workspaces:
          - name: source
            description: "Source code workspace"
        steps:
          - name: install-and-build
            image: registry.access.redhat.com/ubi8/nodejs-18:latest
            workingDir: $(workspaces.source.path)
            script: |
              #!/bin/bash
              set -xe
              
              echo "Installing dependencies..."
              npm install
              
              echo "Building application..."
              npm run build
              
              echo "Build completed successfully"
              ls -la
      workspaces:
        - name: source
          workspace: shared-workspace

    # Task 3: Create S2I BuildConfig and trigger build
    - name: build-image
      runAfter: ["build-app"]
      taskSpec:
        description: "Create S2I build and push container image"
        params:
          - name: IMAGE_REPOSITORY
            description: "Image repository"
            type: string
          - name: IMAGE_TAG
            description: "Image tag"
            type: string
          - name: PROJECT_NAME
            description: "OpenShift project name"
            type: string
        workspaces:
          - name: source
            description: "Source code workspace"
        steps:
          - name: create-s2i-build
            image: registry.redhat.io/openshift4/ose-cli:latest
            workingDir: $(workspaces.source.path)
            env:
              - name: HOME
                value: $(workspaces.source.path)
              - name: KUBECONFIG
                value: $(workspaces.source.path)/.kube/config
            script: |
              #!/bin/bash
              set -xe
              
              echo "Creating S2I BuildConfig..."
              
              # Create .kube directory in workspace to avoid permission issues
              mkdir -p $(workspaces.source.path)/.kube
              
              # Switch to the correct project
              oc project $(params.PROJECT_NAME)
              
              # Delete existing BuildConfig if it exists
              oc delete buildconfig cn-docs-s2i --ignore-not-found=true
              
              # Create new BuildConfig using S2I strategy
              oc new-build nodejs:18-ubi9~. \
                --name=cn-docs-s2i \
                --to=$(params.IMAGE_REPOSITORY):$(params.IMAGE_TAG) \
                --strategy=source \
                --env NPM_CONFIG_PRODUCTION=false \
                --env NODE_ENV=production
              
              echo "Starting S2I build..."
              
              # Start the build and wait for completion
              oc start-build cn-docs-s2i --from-dir=. --wait --follow
              
              echo "S2I build completed successfully"
              
              # Verify the image was built (check the target ImageStream, not the BuildConfig name)
              oc get imagestream cn-docs -o yaml | grep -A 5 "tags:" || true
              
              echo "Image successfully built and pushed to $(params.IMAGE_REPOSITORY):$(params.IMAGE_TAG)"
      params:
        - name: IMAGE_REPOSITORY
          value: $(params.image-repository)
        - name: IMAGE_TAG
          value: $(params.image-tag)
        - name: PROJECT_NAME
          value: $(params.project-name)
      workspaces:
        - name: source
          workspace: shared-workspace

    # Task 4: Deploy to OpenShift
    - name: deploy
      runAfter: ["build-image"]
      taskSpec:
        description: "Deploy to OpenShift"
        params:
          - name: IMAGE_REPOSITORY
            type: string
          - name: IMAGE_TAG
            type: string
          - name: PROJECT_NAME
            type: string
        workspaces:
          - name: source
            description: "Source code workspace"
        steps:
          - name: deploy
            image: registry.redhat.io/openshift4/ose-cli:latest
            workingDir: $(workspaces.source.path)
            env:
              - name: HOME
                value: $(workspaces.source.path)
              - name: KUBECONFIG
                value: $(workspaces.source.path)/.kube/config
            script: |
              #!/bin/bash
              set -xe
              
              echo "Deploying to OpenShift..."
              
              # Create .kube directory in workspace to avoid permission issues
              mkdir -p $(workspaces.source.path)/.kube
              
              # Switch to project
              oc project $(params.PROJECT_NAME)
              
              # Deploy using Helm (preferred method)
              echo "Deploying using Helm..."
              
              # Check if Helm is available
              if command -v helm &> /dev/null; then
                echo "Using Helm for deployment..."
                
                # Deploy using Helm chart
                helm upgrade --install cn-docs ./infrastructure/helm \
                  --namespace $(params.PROJECT_NAME) \
                  --set image.repository=$(params.IMAGE_REPOSITORY) \
                  --set image.tag=$(params.IMAGE_TAG) \
                  --set image.pullPolicy=Always \
                  --set openshift.route.host=docs.cloudnative.rs \
                  --wait --timeout=10m
                
                echo "Helm deployment completed successfully!"
              else
                echo "Helm not available, using native OpenShift commands..."
                
                # Fallback to native OpenShift commands
                oc create deployment cn-docs --image=$(params.IMAGE_REPOSITORY):$(params.IMAGE_TAG) --dry-run=client -o yaml | \
                oc apply -f -
                
                # Expose the service if it doesn't exist
                oc expose deployment cn-docs --port=3000 --target-port=3000 --dry-run=client -o yaml | \
                oc apply -f -
                
                # Create route with custom domain
                oc create route edge cn-docs \
                  --service=cn-docs \
                  --hostname=docs.cloudnative.rs \
                  --dry-run=client -o yaml | \
                oc apply -f -
                
                # Wait for deployment to be ready
                oc rollout status deployment/cn-docs --timeout=300s
                
                echo "Native OpenShift deployment completed successfully!"
              fi
              
              # Get deployment status
              oc get pods -n $(params.PROJECT_NAME)
              oc get routes -n $(params.PROJECT_NAME)
      params:
        - name: IMAGE_REPOSITORY
          value: $(params.image-repository)
        - name: IMAGE_TAG
          value: $(params.image-tag)
        - name: PROJECT_NAME
          value: $(params.project-name)
      workspaces:
        - name: source
          workspace: shared-workspace

    # Task 5: Verify and fix route health
    - name: verify-route
      runAfter: ["deploy"]
      taskSpec:
        description: "Verify route health and fix if needed"
        params:
          - name: APP_NAME
            type: string
          - name: NAMESPACE
            type: string
          - name: ROUTE_HOSTNAME
            type: string
        workspaces:
          - name: source
            description: "Source code workspace"
        steps:
          - name: route-health-check
            image: registry.redhat.io/openshift4/ose-cli:latest
            workingDir: $(workspaces.source.path)
            env:
              - name: HOME
                value: $(workspaces.source.path)
              - name: KUBECONFIG
                value: $(workspaces.source.path)/.kube/config
            script: |
              #!/bin/bash
              set -xe
              
              echo "🔍 Verifying route health for $(params.APP_NAME)"
              
              # Create .kube directory in workspace to avoid permission issues
              mkdir -p $(workspaces.source.path)/.kube
              
              # Switch to project
              oc project $(params.NAMESPACE)
              
              # Copy and run health check script
              chmod +x scripts/route-health-check.sh
              
              # Set environment variables
              export NAMESPACE=$(params.NAMESPACE)
              export APP_NAME=$(params.APP_NAME)
              export SERVICE_NAME=$(params.APP_NAME)
              export ROUTE_HOSTNAME=$(params.ROUTE_HOSTNAME)
              
              # Run health check
              ./scripts/route-health-check.sh check
              
              echo "✅ Route verification completed successfully"
      params:
        - name: APP_NAME
          value: $(params.project-name)
        - name: NAMESPACE
          value: $(params.project-name)
        - name: ROUTE_HOSTNAME
          value: "docs.cloudnative.rs"
      workspaces:
        - name: source
          workspace: shared-workspace
